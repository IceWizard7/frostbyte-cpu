<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Assembler UI</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="container" style="flex-direction: row; width: 100vw; height: 100vh; padding: 20px; gap: 20px;">
        <div class="box" style="flex: 1;">
            <button class="collapsible active">Input & Output</button>
            <div class="content">

            <button class="sub-collapsible">Letter Display</button>
            <div class="sub-content">
                <span class="value" id="letters-value" style="color: white; font-size: 25px; font-weight: bold; text-overflow: unset; width: fit-content; overflow: visible; background-color: #2a2a2a; display: inline-block; padding: 5px 10px; border-radius: 6px; align-items: baseline; margin-left: 0px;">{{ letters }}</span>
            </div>

            <button class="sub-collapsible">Number Display</button>
            <div class="sub-content">
                <span class="value" id="number-value" style="color: white; font-size: 25px; font-weight: bold; text-overflow: unset; width: fit-content; overflow: visible; background-color: #2a2a2a; display: inline-block; padding: 5px 10px; border-radius: 6px; align-items: baseline; margin-left: 0px;">{{ number }}</span>
            </div>

                <div class="lamp-grid">
                    <div style="display: grid; grid-template-columns: repeat(31, 15px); grid-gap: 0.5px;">
                        {% for row in screen_data %}
                            {% for pixel in row %}
                                <img
                                    src="{{ url_for('static', filename='redstone_lamp_on.png') if pixel else url_for('static', filename='redstone_lamp_off.png') }}"
                                    alt=""
                                    class="lamp-pixel"
                                />
                            {% endfor %}
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>

    <div class="box" style="flex: 2;">
        <button class="collapsible active">Memory & Controls</button>
        <div class="content">
            <button class="sub-collapsible">Program Counter</button>
            <div class="sub-content">
                <div><span class="label">PC</span>: <span class="value" id="pc-value">{{ pc }}</span></div>
            </div>

            <button class="sub-collapsible">Registers</button>
            <div class="sub-content">
                {% for name, value in registers.items() %}
                    <div>
                        <span class="label">{{ name }}</span>:
                        <span class="value register-value" data-reg="{{ name }}">{{ value }}</span>
                    </div>
                {% endfor %}
            </div>

            <button class="sub-collapsible">Ports (Source, Read-Only)</button>
            <div class="sub-content">
                {% for name, value in ps.items() %}
                    <div>
                        <span class="label">{{ name }}</span>:
                        <span class="value port-ps-value" data-ps="{{ name }}">{{ value }}</span>
                    </div>
                {% endfor %}
            </div>

            <button class="sub-collapsible">Ports (Destination, Write-Only)</button>
                <div class="sub-content">
                    {% for name, value in pd.items() %}
                        <div>
                            <span class="label">{{ name }}</span>:
                            <span class="value port-pd-value" data-pd="{{ name }}">{{ value }}</span>
                        </div>
                    {% endfor %}
            </div>

            <button class="sub-collapsible">Data Memory</button>
            <div class="sub-content">
                {% for name, value in data_memory.items() %}
                    <div>
                        <span class="label">{{ name }}</span>:
                        <span class="value data-memory-value" data-mem="{{ name }}">{{ value }}</span>
                    </div>
                {% endfor %}
            </div>

            <button class="sub-collapsible">Call Stack</button>
            <div class="sub-content">
                {% for name, value in call_stack.items() %}
                    <div>
                        <span class="label">{{ name }}</span>:
                        <span class="value callstack-value" data-call="{{ name }}">{{ value }}</span>
                    </div>
                {% endfor %}
                <!-- <div><span class="label">CS</span>: <span class="value callstack-value" style="color: white; text-overflow: unset; width: fit-content; overflow: visible; background-color: #2a2a2a; display: inline-block; padding: 5px 10px; border-radius: 6px; align-items: baseline; margin-left: 0px;">{{ call_stack }}</span></div> -->
            </div>

            <button class="sub-collapsible">ALU Flags</button>
            <div class="sub-content">
                {% for name, value in alu_flags.items() %}
                    <div>
                        <span class="label">{{ name }}</span>:
                        <span class="value alu-flag-value" data-flag="{{ name }}">{{ value }}</span>
                    </div>
                {% endfor %}
            </div>

            <h4>Controls</h4>
            <div class="controls-wrapper">
                <label for="speed-slider">Instructions / Second: <output id="speed-output">{{ speed_value | default(100) }}</output></label>
                <div class="speed-control-group">
                    <button type="button" class="speed-btn" id="speed-decrement">-</button>
                    <input type="range" id="speed-slider" name="speed" min="1" max="2500" value="{{ speed_value | default(100) }}">
                    <button type="button" class="speed-btn" id="speed-increment">+</button>
                    <input type="number" id="speed-input" min="1" max="2500" value="{{ speed_value | default(100) }}">
                </div>

                <button id="reset-btn">Reset</button>
                <button id="step-btn">Step</button>
                <button id="stop-btn">Stop</button>
                <button id="continue-btn">Continue</button>
                <button id="gen-schem-btn">Generate Schematic</button>
                <div id="gen-schem-status" style="margin-top: 10px; color: limegreen;"></div>

            </div>
        </div>
    </div>

    <div class="box" style="flex: 1;">
        <button class="collapsible active">Input & Upload</button>
        <div class="content">
            <div style="display: flex; flex-direction: column;">
                <!--
                <form method="POST" action="/" style="margin-bottom: 10px;">
                    <textarea name="codeInput" rows="30" style="width: 100%; font-size: 20px;">{{ saved_text }}</textarea>
                    <button type="submit">Save</button>
                </form>
                -->

                <textarea id="codeInput" rows="30" style="width: 100%; font-size: 20px;">{{ saved_text }}</textarea>
                <button onclick="saveText()">Save</button>
                <div id="save-status" style="margin-top: 10px; color: limegreen;"></div>

                <div id="code-viewer">
                    <!--{% for line in preprocessed_assembly %}
                        <div class="code-line" data-line="{{ loop.index0 }}">{{ line|e }}</div>
                    {% endfor %}-->
                    <div id="assembly-code"></div>
                </div>

            </div>
            <div id="drop-area" style="margin-top: 10px; border: 2px dashed #444; padding: 20px; border-radius: 10px;">
                <p>Drag & Drop a .txt file here</p>
            </div>
        </div>
    </div>
</div>
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
    const socket = io();

    const MIN_INTERVAL = 50; // ms
    let lastUpdateTime = 0;
    let latestData = null;
    let updateScheduled = false;

    socket.on('simulation_update', (data) => {
        // console.log("data received", data);

        latestData = data;

        const now = Date.now()
        const timeSinceLast = now - lastUpdateTime;

        if (timeSinceLast >= MIN_INTERVAL) {
            performUIUpdate(latestData);
            lastUpdateTime = now;
            updateScheduled = false;
        } else if (!updateScheduled) {
            updateScheduled = true;
            setTimeout(() => {
                performUIUpdate(latestData);
                lastUpdateTime = Date.now();
                updateScheduled = false;
            }, MIN_INTERVAL - timeSinceLast);
        }
    });


    function performUIUpdate(data) {
        // console.log("Performing UI update", data);

        // Update Program Counter
        document.getElementById('pc-value').textContent = data.pc;

        // Update Registers
        document.querySelectorAll('.register-value').forEach(span => {
            const name = span.dataset.reg;
            if (data.registers[name]) span.textContent = data.registers[name];
        });

        // Update Read-Only Ports (ps)
        document.querySelectorAll('.port-ps-value').forEach(span => {
            const name = span.dataset.ps;
            if (data.ps[name]) span.textContent = data.ps[name];
        });

        // Update Write-Only Ports (pd)
        document.querySelectorAll('.port-pd-value').forEach(span => {
            const name = span.dataset.pd;
            if (data.pd[name]) span.textContent = data.pd[name];
        });

        // Update Data Memory
        document.querySelectorAll('.data-memory-value').forEach(span => {
            const name = span.dataset.mem;
            if (data.data_memory[name]) span.textContent = data.data_memory[name];
        });

        // Update Call Stack
        document.querySelectorAll('.callstack-value').forEach(span => {
            const name = span.dataset.call;
            if (data.call_stack[name]) span.textContent = data.call_stack[name];
        });

        // Update ALU Flags
        document.querySelectorAll('.alu-flag-value').forEach(span => {
            const name = span.dataset.flag;
            span.textContent = data.alu_flags[name];
        });

        // Update Letters and Number
        document.getElementById('letters-value').textContent = data.letters;
        document.getElementById('number-value').textContent = data.number;

        // Update Screen Data
        const flatPixels = data.screen_data.flat();
        document.querySelectorAll('.lamp-pixel').forEach((img, i) => {
            img.src = flatPixels[i]
                ? "/static/redstone_lamp_on.png"
                : "/static/redstone_lamp_off.png";
        });

        // Update Assembly Code Display
        const assemblyContainer = document.getElementById('assembly-code');
        if (data.preprocessed_assembly) {
            assemblyContainer.innerHTML = ''; // Clear existing content
            data.preprocessed_assembly.forEach((line, index) => {
                const div = document.createElement('div');
                div.className = 'code-line';
                div.dataset.line = index;
                div.textContent = line;
                assemblyContainer.appendChild(div);
            });
        }

        // Highlight current line
        const currentLine = data.int_pc;
        const lineElement = document.querySelector(`.code-line[data-line="${currentLine}"]`);
        // console.log("Highlighting line:", currentLine);

        document.querySelectorAll('.code-line').forEach(line => {
            line.classList.remove('highlight');
        });

        if (lineElement) {
            lineElement.classList.add('highlight');
            // lineElement.scrollIntoView({ behavior: 'smooth', block: 'center' }); // Optional Auto-Scroll
        } else {
            console.warn("No .code-line found for index:", currentLine);
        }
    };

    document.getElementById('reset-btn').addEventListener('click', () => {
        socket.emit('reset_simulation');
    });

    document.getElementById('step-btn').addEventListener('click', () => {
        socket.emit('step_simulation');
    });

    document.getElementById('stop-btn').addEventListener('click', () => {
        socket.emit('stop_simulation');
    });

    document.getElementById('continue-btn').addEventListener('click', () => {
        socket.emit('continue_simulation');
    });

    document.getElementById('gen-schem-btn').addEventListener('click', () => {
        socket.emit('generate_schematic', (response) => {
            document.getElementById('gen-schem-status').textContent = 'Generated Schematic successfully!';
            setTimeout(() => {
                document.getElementById('gen-schem-status').textContent = '';
            }, 750);
        });
    });

    // On website Load, Request an Update
    document.addEventListener('DOMContentLoaded', () => {
        socket.emit('request_update');
    });

    // Save the expanded/collapsed state
    function saveCollapseState(buttonClass) {
        const states = {};
        document.querySelectorAll(buttonClass).forEach((btn, index) => {
            states[index] = btn.classList.contains("active");
        });
        localStorage.setItem(buttonClass, JSON.stringify(states));
    }

    // Restore the state and update visibility
    function restoreCollapseState(buttonClass, contentClass) {
        const saved = localStorage.getItem(buttonClass);
        if (!saved) return;

        const states = JSON.parse(saved);
        const buttons = document.querySelectorAll(buttonClass);
        const contents = document.querySelectorAll(contentClass);

        buttons.forEach((btn, index) => {
            const content = contents[index];
            if (states[index]) {
                btn.classList.add("active");
                content.style.display = "grid"; // Changed to grid
            } else {
                btn.classList.remove("active");
                content.style.display = "none";
            }
        });
    }

    // Setup toggling logic
    function setupToggle(buttonClass, contentClass) {
        const buttons = document.querySelectorAll(buttonClass);
        const contents = document.querySelectorAll(contentClass);

        buttons.forEach((btn, index) => {
            btn.addEventListener("click", () => {
                btn.classList.toggle("active");
                const content = contents[index];
                if (btn.classList.contains("active")) {
                    content.style.display = "grid"; // Changed to grid
                } else {
                    content.style.display = "none";
                }
                saveCollapseState(buttonClass);
            });
        });
    }

    // Initialize collapsibles and sub-collapsibles
    document.addEventListener('DOMContentLoaded', restoreCollapseState(".collapsible", ".content"));
    document.addEventListener('DOMContentLoaded', restoreCollapseState(".sub-collapsible", ".sub-content"));
    setupToggle(".collapsible", ".content");
    setupToggle(".sub-collapsible", ".sub-content");

    // Drag & Drop logic
    const dropArea = document.getElementById("drop-area");

    ["dragenter", "dragover"].forEach(eventName => {
        dropArea.addEventListener(eventName, e => {
            e.preventDefault();
            dropArea.style.backgroundColor = "#333";
        }, false);
    });

    ["dragleave", "drop"].forEach(eventName => {
        dropArea.addEventListener(eventName, e => {
            e.preventDefault();
            dropArea.style.backgroundColor = "transparent";
        }, false);
    });

    // Speed Control Synchronization Logic
    const speedSlider = document.getElementById('speed-slider');
    const speedInput = document.getElementById('speed-input');
    const speedOutput = document.getElementById('speed-output');
    const incButton = document.getElementById('speed-increment');
    const decButton = document.getElementById('speed-decrement');

    const SPEED_STORAGE_KEY = 'speedValue'; // Key for localStorage

    // Function to update all speed elements
    function updateSpeed(value) {
        const clampedValue = Math.max(1, Math.min(2500, value)); // Enforce min/max
        speedSlider.value = clampedValue;
        speedInput.value = clampedValue;
        speedOutput.textContent = clampedValue;
        localStorage.setItem(SPEED_STORAGE_KEY, clampedValue); // Save the value

        socket.emit("update_speed", { speed: clampedValue });
    }

    // Function to restore speed from localStorage
    function restoreSpeed() {
        const savedSpeed = localStorage.getItem(SPEED_STORAGE_KEY);
        if (savedSpeed !== null) {
            updateSpeed(parseInt(savedSpeed));
        } else {
            updateSpeed(parseInt(speedSlider.value)); // Use initial slider value if nothing saved
        }
    }

    document.addEventListener('DOMContentLoaded', restoreSpeed);

    speedSlider.addEventListener('input', () => updateSpeed(speedSlider.value));
    speedInput.addEventListener('input', () => updateSpeed(speedInput.value));

    incButton.addEventListener('click', () => updateSpeed(parseInt(speedSlider.value) + 1));
    decButton.addEventListener('click', () => updateSpeed(parseInt(speedSlider.value) - 1));

    // When the user types a value and clicks away, re-validate
    speedInput.addEventListener('change', () => updateSpeed(speedInput.value));

    dropArea.addEventListener("drop", e => {
        const file = e.dataTransfer.files[0];
        if (!file || file.type !== "text/plain") {
            alert("Please drop a .txt file.");
            return;
        }

        const formData = new FormData();
        formData.append("file", file);

        fetch("/upload", {
            method: "POST",
            body: formData
        })
        .then(response => {
            if (response.ok) {
                location.reload(); // Reload to show updated code
            } else {
                alert("Upload failed.");
            }
        })
        .catch(err => {
            alert("Upload error.");
            console.error(err);
        });
    });

    function saveText() {
        const text = document.getElementById('codeInput').value;
        fetch('/save', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({ codeInput: text }),
        }).then(() => {
            document.getElementById('save-status').textContent = 'Saved successfully!';
            setTimeout(() => {
                document.getElementById('save-status').textContent = '';
            }, 750);
        });

        socket.emit('request_update');
    }
</script>
</body>
</html>